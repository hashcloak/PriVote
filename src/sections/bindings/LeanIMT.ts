/* Autogenerated file, do not edit! */

/* eslint-disable */
import {AztecAddress, CompleteAddress} from '@aztec/aztec.js/addresses';
import {
    type AbiType,
    type AztecAddressLike,
    type ContractArtifact,
    EventSelector,
    decodeFromAbi,
    type EthAddressLike,
    type FieldLike,
    type FunctionSelectorLike,
    loadContractArtifact,
    loadContractArtifactForPublic,
    type NoirCompiledContract,
    type U128Like,
    type WrappedFieldLike
} from '@aztec/aztec.js/abi';
import {
    Contract,
    ContractBase,
    ContractFunctionInteraction,
    type ContractInstanceWithAddress,
    type ContractMethod,
    type ContractStorageLayout,
    DeployMethod
} from '@aztec/aztec.js/contracts';
import {EthAddress} from '@aztec/aztec.js/addresses';
import {Fr, Point} from '@aztec/aztec.js/fields';
import {type PublicKey, PublicKeys} from '@aztec/aztec.js/keys';
import type {Wallet} from '@aztec/aztec.js/wallet';
import LeanIMTContractArtifactJson from '../../assets/lean_imt-LeanIMT.json' with {type: 'json'};

export const LeanIMTContractArtifact = loadContractArtifact(LeanIMTContractArtifactJson as NoirCompiledContract);


/**
 * Type-safe interface for contract LeanIMT;
 */
export class LeanIMTContract extends ContractBase {

    private constructor(
        instance: ContractInstanceWithAddress,
        wallet: Wallet,
    ) {
        super(instance, LeanIMTContractArtifact, wallet);
    }


    /**
     * Creates a contract instance.
     * @param address - The deployed contract's address.
     * @param wallet - The wallet to use when interacting with the contract.
     * @returns A promise that resolves to a new Contract instance.
     */
    public static async at(
        address: AztecAddress,
        wallet: Wallet,
    ) {
        return Contract.at(address, LeanIMTContract.artifact, wallet) as Promise<LeanIMTContract>;
    }


    /**
     * Creates a tx to deploy a new instance of this contract.
     */
    public static deploy(wallet: Wallet,) {
        return new DeployMethod<LeanIMTContract>(PublicKeys.default(), wallet, LeanIMTContractArtifact, LeanIMTContract.at, Array.from(arguments).slice(1));
    }

    /**
     * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
     */
    public static deployWithPublicKeys(publicKeys: PublicKeys, wallet: Wallet,) {
        return new DeployMethod<LeanIMTContract>(publicKeys, wallet, LeanIMTContractArtifact, LeanIMTContract.at, Array.from(arguments).slice(2));
    }

    /**
     * Creates a tx to deploy a new instance of this contract using the specified constructor method.
     */
    public static deployWithOpts<M extends keyof LeanIMTContract['methods']>(
        opts: { publicKeys?: PublicKeys; method?: M; wallet: Wallet },
        ...args: Parameters<LeanIMTContract['methods'][M]>
    ) {
        return new DeployMethod<LeanIMTContract>(
            opts.publicKeys ?? PublicKeys.default(),
            opts.wallet,
            LeanIMTContractArtifact,
            LeanIMTContract.at,
            Array.from(arguments).slice(1),
            opts.method ?? 'constructor',
        );
    }


    /**
     * Returns this contract's artifact.
     */
    public static get artifact(): ContractArtifact {
        return LeanIMTContractArtifact;
    }

    /**
     * Returns this contract's artifact with public bytecode.
     */
    public static get artifactForPublic(): ContractArtifact {
        return loadContractArtifactForPublic(LeanIMTContractArtifactJson as NoirCompiledContract);
    }


    public static get storage(): ContractStorageLayout<'size' | 'depth' | 'sideNodes' | 'leaves'> {
        return {
            size: {
                slot: new Fr(1n),
            },
            depth: {
                slot: new Fr(2n),
            },
            sideNodes: {
                slot: new Fr(3n),
            },
            leaves: {
                slot: new Fr(4n),
            }
        } as ContractStorageLayout<'size' | 'depth' | 'sideNodes' | 'leaves'>;
    }


    /** Type-safe wrappers for the public methods exposed by the contract. */
    public declare methods: {

        /** get_root() */
        get_root: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

        /** insert(leaf: field) */
        insert: ((leaf: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

        /** process_message(message_ciphertext: struct, message_context: struct) */
        process_message: ((message_ciphertext: FieldLike[], message_context: {
            tx_hash: FieldLike,
            unique_note_hashes_in_tx: FieldLike[],
            first_nullifier_in_tx: FieldLike,
            recipient: AztecAddressLike
        }) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

        /** public_dispatch(selector: field) */
        public_dispatch: ((selector: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

        /** sync_private_state() */
        sync_private_state: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;
    };


}
